Asteroid Animation:

Create the following asteroid/impact animation using HTML/CSS/JavaScript/three.js following this directive exactly:

1) Runtime & rendering constraints (foundation)

Use WebGLRenderer (Three.js uses WebGL2; WebGL1 is not supported since r163).[1]

Use WebGLRenderer.setAnimationLoop() as the sole render loop entrypoint.[1]

Use EffectComposer for post, since it manages an ordered chain of passes and renders the last enabled pass to screen.[2]

Use renderer.outputColorSpace for output color space and renderer.toneMapping/renderer.toneMappingExposure for tone mapping + exposure.[1]

Use OutputPass as the final post step when using the composer chain.[2][23]

2) High-level system architecture (modules and responsibilities)
2.1 Scene graph layout (explicit nodes)

Create these top-level nodes (Object3D groups), and never mix responsibilities across them:

G_ENV — sky, stars, atmospheric fog.

G_ASTEROID — the main body mesh + hot rim/plasma shell + near-field shock glow.

G_TRAIL — long tail (smoke/ion/plasma) + ash volume layers.

G_DEBRIS — instanced shards + embers/sparks + dust motes.

G_GROUND — ground plane/terrain + impact site decal/crater mesh + secondary dust.

G_POST — (not in scene graph) composer chain.

Use Object3D.renderOrder to force deterministic ordering between opaque ground/asteroid vs. transparent trails when needed.[22]

2.2 Update loop order (fixed)

Per frame:

Compute dt (seconds) and advance T (timeline normalized).

Update camera (position/aim/shake) based on T.

Update asteroid kinematics (position/orientation/scale) based on T.

Update continuous emitters (trail smoke/ash) based on T and asteroid state.

Update particle simulations (debris, dust) with dt (spawn → integrate → kill → write GPU buffers).

Update impact subsystem (only active after T >= T_IMPACT).

Render via composer.render(dt) (or composer.render(); the composer can compute its own delta if not provided).[2]

3) Asset & content pipeline (what the dev must prepare)
3.1 Asteroid geometry LOD stack (required)

Provide 3 LOD meshes (far/mid/near), and switch by distance using LOD.[6]

LOD selection distances must be tied to camera-to-asteroid distance, not T, so camera changes don’t break LOD.[6]

3.2 Material set (asteroid)

Target a PBR look using either:

MeshPhysicalMaterial where needed for advanced surface response features (clearcoat, etc.).[24]

Otherwise use baseline PBR materials (dev choice), but keep all textures authored consistently (albedo/normal/roughness/AO/emissive).

3.3 Trail textures (required)

Prepare:

Smoke flipbook atlas (RGBA) for near-field smoke billboards.

Ash/dust atlas (RGBA) with softer edges and more granular detail.

Embers/sparks atlas (RGBA) for additive particles.

3.4 Ground & decals (required)

Provide:

Ground tile textures (albedo/normal/roughness/AO).

Impact decal texture(s): scorch, ejecta ring, cracks (RGBA).

3.5 Loading format

Prefer glTF 2.0 for meshes via GLTFLoader.[18]

Implement explicit disposal for textures/bitmaps; GLTFLoader warns that image bitmaps are not automatically garbage collected and require special handling during disposal.[18]

4) Environment (night sky + atmosphere)
4.1 Sky & stars

Implement one (pick A for simplicity, keep B as optional upgrade):

A) Starfield points

Build a BufferGeometry with star positions and render using Points.[10][4]

Keep stars in G_ENV and place them at a very large radius around the camera, or implement camera-relative stars to avoid precision issues.

B) HDRI skydome (optional)

Use a night HDR as background/environment and prefilter with PMREMGenerator for material roughness response.[20]

If using a “room-like” placeholder environment during dev, RoomEnvironment exists to generate a PMREM usable for image-based lighting via Scene#environment or as an environment map to PBR materials.[21]

4.2 Atmospheric extinction / fog

Use FogExp2 for exponential-squared haze to blend distant tail/asteroid into the night and sell scale.[11]

Drive fog density by timeline T (light fog early; heavier dust/haze after impact) using a piecewise curve.

5) Core animation: asteroid approach (camera + kinematics)
5.1 Timeline definition (canonical)

Define timeline checkpoints (normalized, tunable constants):

T0 = 0.00 far speck in sky

T1 ≈ 0.20 visible disk, faint tail starts

T2 ≈ 0.55 rapid growth, strong ablation + debris streaks

T3 ≈ 0.80 near-field rumble: aggressive parallax, bright hot rim, heavy smoke

T_IMPACT ≈ 0.92 first contact / explosion flash

T_END = 1.00 settling dust / aftermath

5.2 Kinematic path (deterministic, camera-facing drama)

Drive asteroid world position along a curve that is nearly collinear with camera forward early, then introduces slight lateral offset near T3 to create parallax and scale cues.

Keep size increase physically plausible-looking by combining true approach (distance shrink) plus a modest nonlinear ease for cinematic timing (avoid constant-speed “gamey” motion).

5.3 Camera system (three layered behaviors)

Base track: camera anchored (viewer perspective) until T2, then subtle backward drift and slight aim correction so the asteroid stays near center.

Shake: procedural camera micro-jitter ramping from T2 to T_IMPACT and peaking at impact; decay after.

Impact impulse: a short, high-amplitude kick at T_IMPACT plus quick recovery for “blast” feel.

6) Asteroid lookdev (body + heating) — how to get “realistic” with vanilla Three.js
6.1 Body shading

Use normal + roughness variation and strong grazing-angle highlights to avoid a “flat rock” look.

Ensure consistent lighting response by using renderer.toneMapping and renderer.outputColorSpace rather than baking a “finished” look into textures.[1]

6.2 Heating / ablation shell (near-field glow)

Implement a second render layer around the asteroid:

Option A (recommended): a slightly inflated duplicate mesh (or shell) rendered additively with a ShaderMaterial that uses view-angle and a noise field to modulate brightness.[3]

Option B: a camera-facing “hot rim” ring using billboards (Sprite) placed along the silhouette as a cheaper approximation.[7][8]

For any vertex displacement performed in custom shaders, plan shadow correctness:

If the asteroid is shadow-casting with directional/spot lights and vertices move in the shader, Three.js supports assigning Object3D.customDepthMaterial for proper shadows.[22]

7) Trails: smoke, ash, and plasma (multi-system, layered, no code dependencies)
7.1 Design principle (what makes it believable)

Use at least three trail layers that each behave differently:

Hot/ion core (fast, bright, thin, turbulent).

Dense smoke plume (slower, larger sprites, curls, high opacity near source).

Ash/dust volume (fine particulate, wide spread, long persistence).

7.2 Implementation: GPU-friendly particle approach (vanilla)

Use a single particle framework based on:

BufferGeometry attributes (position, velocity, age, lifetime, size, rotation, seed, frameIndex).[4]

Render as Points for the ash layer and/or billboard quads using a custom ShaderMaterial for smoke flipbooks.[10][3]

You will author two emitter modes:

A) Continuous emitter (approach phase)

Spawn rate increases with T and with asteroid “heating factor”.

Emitters are attached to G_ASTEROID so the near-field plume originates at the body.

B) Burst emitter (impact phase)

A single large burst at T_IMPACT spawns shock dust, ejecta, embers, and secondary smoke.

7.3 Transparency handling (critical for smoke realism)

Prefer Material.alphaHash for dense smoke layers where you need stable depth and less sorting artifacts; alphaHash is a material property specifically for hashed alpha.[9]

Use Object3D.renderOrder for deterministic layering when mixing multiple transparent systems.[22]

Keep far smoke more transparent and more fog-affected (tie shader opacity to distance + scene fog uniforms via shader fog support if using ShaderMaterial fog uniforms).[3][11]

7.4 Frustum culling & bounds

Large particle systems may not have accurate bounds; manage culling explicitly via Object3D.frustumCulled when needed.[22]

8) Debris: fragments + sparks + dust motes
8.1 Two debris tiers

Macro fragments (visible chunks) — instanced meshes.

Micro particles (sparks/embers/dust) — points/billboards.

8.2 Macro fragments (performance + realism)

Use InstancedMesh for shards to reduce draw calls and improve rendering performance.[5]

Each child instance stores: transform, initial velocity, angular velocity, birth time, lifetime.

Use ballistic motion (gravity after impact; minimal drag), and kill or fade instances after lifetime.

8.3 Micro particles

Use Points for dust motes and Sprite for embers as needed.[10][7]

Keep embers additive and short-lived; keep dust long-lived and fog-influenced.

9) Impact subsystem (the “realness” is in staging)
9.1 Impact event choreography (single source of truth)

At T_IMPACT, trigger an event object:

impactTimeSeconds (actual wall time)

impactPointWorld (ground intersection point)

impactNormalWorld

impactEnergyScalar (art-directed)

All impact visuals derive from this object, not from guessed positions.

9.2 Visual components (must implement all)

Flash: a very short bloom-driving burst (billboard or emissive plane) + exposure spike curve.

Crater / ground deformation: swap in a pre-modeled crater mesh or blend a displacement patch; place decals.

Ejecta cone: fast burst of macro fragments + dark dust.

Ground-hugging dust ring: expanding ring of dust sprites close to ground.

Rising column: slower, tall smoke/dust volume and falling ash.

Use Object3D.renderOrder to keep the flash and dust ring visually coherent in the first 10–20 frames after impact.[22]

10) Lighting strategy (simple, stable, cinematic)
10.1 Light set (minimal)

One key “moonlight” directional light + low ambient fill.

Optional: a warm, high-intensity point light at impact that decays quickly (drives crater illumination).

10.2 Shadows (if enabled)

Keep shadow casters minimal; Object3D.castShadow and Object3D.receiveShadow control whether objects render into shadow maps and receive shadows.[22]

If using shadows plus vertex-displaced shaders, supply customDepthMaterial as noted earlier.[22]

11) Post-processing chain (realism polish; all available as Three.js addons)
11.1 Composer basics

EffectComposer executes passes in order and renders the last pass to screen.[2]

The composer can resize internal buffers and passes with composer.setSize() and composer.setPixelRatio().[2]

11.2 Recommended pass order (baseline)

RenderPass(scene, camera) (first pass; required as your base chain entry).[2]

Bloom: start with BloomPass (basic bloom); note that docs call out UnrealBloomPass as more advanced but more expensive.[14]

DOF (optional, near-field): BokehPass for depth-of-field.[12]

Grain: FilmPass for film grain.[13]

AA: TAARenderPass only if you can tolerate its accumulation behavior (it accumulates jittered camera samples across frames when there is no motion).[17]

OutputPass final.[23][2]

11.3 Tone mapping & exposure shaping (impact sells “energy”)

Use renderer.toneMapping and renderer.toneMappingExposure for the global response curve.[1]

Drive exposure over time: small ramp up as the asteroid nears; sharp spike at impact; quick clamp down; slow recovery.

12) Resource management & stutter control (must do)
12.1 Precompile shaders

Use WebGLRenderer.compile() or compileAsync() to precompile materials before first critical render; compileAsync() uses KHR_parallel_shader_compile when available.[1]

Run a hidden “warmup” stage: render once with all key materials/passes enabled before starting the cinematic.

12.2 Texture streaming behavior

TextureLoader.load() returns a Texture immediately and can “pop” into the scene when loading finishes if used right away.[19]

Gate the start of the cinematic until all essential textures (asteroid + smoke atlases + ground) are loaded.

12.3 Disposal

Implement explicit disposal for geometries, materials, textures, render targets, and composer passes on teardown; EffectComposer.dispose() exists to free GPU resources it allocated.[2]

Treat glTF-loaded image bitmaps as needing explicit handling per the GLTFLoader guidance about bitmap GC behavior.[18]

13) Concrete implementation spec (what files/classes exist)
13.1 File structure (exact)

src/app.js — bootstrap: renderer, scene, camera, timeline, load orchestration.

src/rendering/renderer.js — renderer init, resize handling, pixel ratio, tone mapping settings.[1]

src/rendering/post.js — composer + pass chain creation, enable/disable toggles.[2]

src/scene/env.js — sky/stars/fog.[10][11]

src/scene/asteroid.js — LOD setup, materials, heating shell.[6][3]

src/fx/particles/particlePool.js — generic typed-array pool + spawn/kill.

src/fx/particles/trailSystem.js — smoke/ash emitters + GPU buffer writes.[4][10][3]

src/fx/particles/debrisSystem.js — instanced shards + micro-particles.[5][10]

src/fx/impact/impactSystem.js — flash, crater placement, shock dust ring, ejecta burst.

src/anim/timeline.js — maps wall-time to normalized T, defines all curves and event triggers.

src/anim/cameraRig.js — camera base, shake, impact impulse.

13.2 Public APIs (exact signatures, no code)

timeline.update(dt) -> { T, events[] }

cameraRig.update(dt, T, asteroidState, impactState)

asteroid.update(dt, T) -> asteroidState { position, velocity, forward, heat }

trailSystem.update(dt, T, asteroidState)

debrisSystem.update(dt, T, asteroidState, impactState)

impactSystem.update(dt, T, asteroidState) -> impactState { active, point, normal, energy }

post.update(dt, T) (exposure/bloom strength/grain amount curves)

14) Parameterization (dev can tune without touching logic)

Define a single JSON-like config object with:

Timeline checkpoints (T1, T2, T3, T_IMPACT).

Asteroid: LOD distances (for LOD).[6]

Trail: spawn rates, lifetimes, size ranges, opacity curves.

Debris: shard count, initial velocity cone, lifetime ranges (approach vs impact).

Fog: base density + post-impact density curve (for FogExp2).[11]

Post: bloom strength, DOF focus/aperture, grain intensity (for FilmPass), exposure curve.[14][12][13][1]

15) Acceptance checklist (what to verify)

LOD switches cleanly according to distance via LOD.[6]

Macro debris uses InstancedMesh and does not balloon draw calls.[5]

Smoke layers do not exhibit catastrophic sorting artifacts; alphaHash and/or renderOrder is applied where required.[9][22]

Post chain renders in expected order through EffectComposer and ends with OutputPass.[2][23]

Renderer is configured with explicit outputColorSpace and toneMapping/toneMappingExposure.[1]

The cinematic starts only after warmup/compile and asset load completion; TextureLoader.load() “pop-in” is not visible at runtime.[19][1]

Impact is triggered once at T_IMPACT and all derived effects reference the same impactState object.

- When complete, run full tests